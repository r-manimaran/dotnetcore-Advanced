@page "/documents"
@using MimeMapping

@using System.ComponentModel.DataAnnotations
@using VectorSearchApp.Services

@inject IServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime

<PageTitle>Documents</PageTitle>

<h4 class="mb-4">    
    <Icon Name="IconName.Upload" class="me-2" />
    Upload new Document
</h4>


<EditForm Model="Model" OnValidSubmit="UploadFile">
    <DataAnnotationsValidator />

    <div class="row">
        <div class="col-md-5 col-sm-4 col-5">
            <div class="input-group">
                <span class="input-group-text">
                    <Tooltip Title="PDF, DOCX, TXT and MD files are supported" Color="TooltipColor.Primary" Placement="TooltipPlacement.Bottom">
                        <Icon Class="d-flex text-body-secondary" Name="IconName.InfoCircle"></Icon>
                    </Tooltip>
                </span>
                <InputFile class="form-control" OnChange="@OnFileChange" accept=".pdf,.docx,.txt,.md" id="fileInput" />
            </div>
        </div>

      
        <div class="col-md-2 col-sm-3 col-2">
            <div class="d-grid gap-2">
                <span class="input-group-text">
                    <Tooltip Title="The unique identifier (GUID) of the document. If not provided, a new one will be generated. If you specify an existing Document ID, the corresponding docment will be overwritten"
                                Color="TooltipColor.Primary" Placement="TooltipPlacement.Bottom">
                        <Icon Class="d-flex text-body-secondary" Name="IconName.InfoCircle"></Icon>
                    </Tooltip>
                    Document ID
                </span>
                <TextInput Placeholder="Enter a valid GUID or leave empty for auto-generation" @bind-Value="@Model.DocumentId" />
            </div>
            <ValidationMessage For="@(() => Model.DocumentId)" />
        </div>

        <div class="col-md-2 col-sm-3 col-2">
            <div class="d-grid gap-2">
                <Button @ref="uploadButton" Type="ButtonType.Submit" Color="ButtonColor.Primary" To="#" Disabled="@(Model.File is null)" 
                Class="w-100 py-2 fw-semibold shadow-sm"><Icon Name="IconName.Upload" /><span class="d-none d-lg-inline ps-3">Upload</span></Button>
            </div>
        </div>
    </div>

</EditForm>

@if(isLoading && documents.Count == 0)
{
    <div class="text-center">
        <Spinner Color="SpinnerColor.Primary" Type="SpinnerType.Border" Size="SpinnerSize.Large" Class="me-3 mt-4" />
    </div>
}
else
{
    <h4 class="mt-4 mb-4">
        <Icon Name="IconName.Files" Class="me-2"/>
        Available Documents
    </h4>

    <div class="table-responsive">
        <table class="table table-hover align-middle mb-0 border rounded overflow-hidden">
            <thead class="table-light sticky-top">
                <tr>
                    <th style="width:40px;"></th>
                    <th class="text-secondary">ID</th>
                    <th class="text-secondary">Name</th>
                    <th class="text-secondary">Content type</th>
                    <th class="text-secondary text-center">Chunks</th>
                    <th class="text-secondary">Created</th>
                </tr>
            </thead>

            <tbody>
                @foreach (var doc in documents)
                {
                    <tr class="@((doc.IsSelected ? "table-primary":null))">
                        <td>
                            <div class="d-flex justify-content-center align-items-center">
                                <CheckboxInput @bind-Value="doc.IsSelected" />
                            </div>
                        </td>
                        <td>@doc.Id</td>
                        <td>@doc.Name</td>
                        <td>
                            <span class="badge content-type-badge px-2 py-1 rounded-pill small">
                                @doc.ContentType
                            </span>

                        </td>

                        <td>@doc.ChunkCount</td>
                        <td>@doc.LocalCreationDateString</td>
                    </tr>
            }
            </tbody>
        </table>
    </div>
    <div class="row">
        <div class="col col-sm-3 col-2">
            <div class="d-grid gap-2">
                <Button @ref="deleteButton" Color="ButtonColor.Danger" Disabled="@(!documents.Any(d => d.IsSelected))" @onclick="DeleteSelectedDocuments" Class="w-100 py-2 fw-semibold shadow-sm">
                    <Icon Name="IconName.Trash" /><span class="d-none d-lg-inline ps-3">Delete</span>
                </Button>
            </div>
        </div>
    </div>

    
}

@code {
    private ConfirmDialog dialog = default!;

    private UploadDocument Model { get; set; } = new();
    private Button uploadButton = default!;
    private Button deleteButton = default!;

    private bool isLoading = true;
    [Inject]
    protected ToastService ToastService { get; set; } = default!;
    private IList<SelectableDocument> documents = [];
    #region Methods

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("OnInitialized called");
        await using var scope = ServiceProvider.CreateAsyncScope();
        await LoadDocumentsAsync(scope.ServiceProvider);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"OnAfterRenderAsync called - firstRender: {firstRender}");
        if (!firstRender)
        {
            Console.WriteLine("Not first render, returning");
            return;
        }
        Console.WriteLine("Starting LoadDocumentsAsync...");

        await using var scope = ServiceProvider.CreateAsyncScope();
        await LoadDocumentsAsync(scope.ServiceProvider);
        StateHasChanged();
    }

    private async Task LoadDocumentsAsync(IServiceProvider serviceProvider)
    {
        isLoading = true;

        try
        {
            var documentService = serviceProvider.GetRequiredService<IDocumentService>();
            var dbDocuments = await documentService.GetAsync();

            documents.Clear();
            foreach(var dbDocument in dbDocuments)
            {
                documents.Add(new SelectableDocument(dbDocument.Id, dbDocument.Name, dbDocument.CreationDate, dbDocument.ChunkCount)
                    {
                        LocalCreationDateString = await GetLocalDateTimeStringAsync(dbDocument.CreationDate)
                    });
            }            
        }
        catch (Exception ex)
        {
            ToastService.Notify(await CreateToastMessage(ToastType.Danger, "Load Error", $"An error occurred while loading documents: {ex.Message}"));
        }
        finally
        {
            isLoading = false;

        }
    }

    private void OnFileChange(InputFileChangeEventArgs e)
    {
        Console.WriteLine("OnFileChange called!"); // Add this first
        Model.File = e.File;
        Console.WriteLine($"File selected: {e.File?.Name}");       
        StateHasChanged(); // Force UI update
    }
    private async Task UploadFile()
    {
        Console.WriteLine($"UploadFile called. Model.File is null: {Model.File is null}");
        if(Model.File is null)
        {
            return;
        }

        var fileName = Model.File.Name;
        try
        {
            await using var inputStream = Model.File.OpenReadStream(20 * 1024 * 1024); // Limit to 20 MB
            await using var stream = await inputStream.GetMemoryStreamAsync();

            await using var scope = ServiceProvider.CreateAsyncScope();
            var vectorSearchService = scope.ServiceProvider.GetRequiredService<IVectorSearchService>();

            var documentId = string.IsNullOrWhiteSpace(Model.DocumentId) ? null : (Guid?)Guid.Parse(Model.DocumentId);
            await vectorSearchService.ImportAsync(stream, fileName, MimeUtility.GetMimeMapping(fileName), documentId);

            ToastService.Notify(await CreateToastMessage(ToastType.Success, "Upload document", $"The document {fileName} has been successfully uploaded and indexed."));

            Model = new UploadDocument();
            await JSRuntime.InvokeVoidAsync("resetFileInput", "fileInput");

            await LoadDocumentsAsync(scope.ServiceProvider);
        }
        catch (Exception ex)
        {
            ToastService.Notify(await CreateToastMessage(ToastType.Danger, "Upload Error", $"An error occurred while uploading the document {fileName}: {ex.Message}"));
        }
        finally
        {
            uploadButton.HideLoading();
        }

    }

    private async Task<ToastMessage> CreateToastMessage(ToastType toastType, string title, string message)
    {
        var toastMessage = new ToastMessage
        {
            Title = title,
            Message = message,
            Type = toastType,
            HelpText = await GetLocalDateTimeStringAsync(DateTimeOffset.UtcNow)
        };
        return toastMessage;
    }

    private async Task<string> GetLocalDateTimeStringAsync(DateTimeOffset dateTimeOffset)
    {
        return dateTimeOffset.ToString("yyyy-MM-dd HH:mm:ss");
    }

    private async Task DeleteSelectedDocuments()
    {
        var selectedDocuments = documents?.Where(d => d.IsSelected).Select(d => d.Id) ?? [];

        var options = new ConfirmDialogOptions
            {
                YesButtonText = "Yes",
                YesButtonColor = ButtonColor.Danger,
                NoButtonText = "No",
                NoButtonColor = ButtonColor.Secondary,
            };

        var confirmation = await dialog.ShowAsync(
            title: "Delete the selected documents?",
            message1: " This will delete the documents and all their corresponding embeddings. This operation cannot be undone.",
            message2: "Do you want to proceed?",
            confirmDialogOptions: options);
        if(!confirmation)
        {
            return;
        }

        try
        {
            deleteButton.ShowLoading();

            await using var scope = ServiceProvider.CreateAsyncScope();
            var documentService = scope.ServiceProvider.GetRequiredService<IDocumentService>();
            await documentService.DeleteAsync(selectedDocuments);

            await LoadDocumentsAsync(scope.ServiceProvider);
            ToastService.Notify(await CreateToastMessage(ToastType.Success, "Delete documents", $"{selectedDocuments.Count()} document(s) have been successfully deleted."));
        }
        catch(Exception ex)
        {
            ToastService.Notify(await CreateToastMessage(ToastType.Danger, "Delete Error", $"An error occurred while deleting documents: {ex.Message}"));
        }
        finally
        {
            deleteButton.HideLoading();
        }
    }
    #endregion


    #region Models
    public class UploadDocument
    {
        public IBrowserFile? File { get; set; }

        [RegularExpression(@"^(\{|\()?[0-9a-fA-F]{8}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{12}(\}|\))?$", ErrorMessage = "Invalid GUID format.")]
        public string? DocumentId { get; set; }
    }

    private record class SelectableDocument(Guid Id, string Name, DateTimeOffset CreationDate, int ChunkCount): Document(Id, Name, CreationDate, ChunkCount)
    {
        public bool IsSelected { get; set; }
        public string ContentType => MimeUtility.GetMimeMapping(Name);
        public string LocalCreationDateString { get; set; } = string.Empty;
    }
    #endregion
}