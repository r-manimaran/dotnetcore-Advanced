@page "/documents"
@using MimeMapping

@using System.ComponentModel.DataAnnotations
@using VectorSearchApp.Services

@inject IServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime

<PageTitle>Documents</PageTitle>

<h4 class="mb-4">    
    <Icon Name="IconName.Upload" class="me-2" />
    Upload new Document
</h4>

<EditForm Model="Model" OnValidSubmit="UploadFile" FormName="UploadDocumentForm">
    <DataAnnotationsValidator />

    <div class="row">
        <div class="col-md-5 col-sm-4 col-5">
            <div class="input-group">
                <span class="input-group-text">
                    <Tooltip Title="PDF, DOCX, TXT and MD files are supported" Color="TooltipColor.Primary" Placement="TooltipPlacement.Bottom">
                        <Icon Class="d-flex text-body-secondary" Name="IconName.InfoCircle"></Icon>
                    </Tooltip>
                </span>
                <InputFile class="form-control" OnChange="@((e)=> Model.File = e.File)" accept=".pdf,.docx,.txt,.md" id="fileInput"/>
            </div>
        </div>

        <div class="col-md-5 col-sm-4 col-5">
            <div class="input-group">
                <TextInput Placeholder="Enter a valid GUID or leave empty for auto-generation" @bind-value="Model.DocumentId" />
            </div>
        </div>
        <div class="col-md-2 col-sm-3 col-2">
            <div class="d-grid gap-2">
                <span class="input-group-text">
                    <Tooltip Title="The unique identifier (GUID) of the document. If not provided, a new one will be generated. If you specify an existing Document ID, the corresponding docment will be overwritten"
                                Color="TooltipColor.Primary" Placement="TooltipPlacement.Bottom">
                        <Icon Class="d-flex text-body-secondary" Name="IconName.InfoCircle"></Icon>
                    </Tooltip>
                    Document ID
                </span>
                <Button @ref="uploadButton" type="ButtonType.Submit" Color="ButtonColor.Primary" To="#"><Icon Name="IconName.Upload" /><span class="d-none d-lg-inline ps-3">Upload</span></Button>
            </div>
        </div>
    </div>

</EditForm>

@if(isLoading && documents.Count == 0)
{
    <div class="text-center">
        <Spinner Color="SpinnerColor.Primary" Type="SpinnerType.Border" Size="SpinnerSize.Large" Class="me-3 mt-4" />
    </div>
}
else
{
    <h4 class="mt-4 mb-4">
        <Icon Name="IconName.Files" Class="me-2"/>
        Available Documents
    </h4>

    @foreach(var doc in documents)
    {
        <td>@doc.Id</td>
        <td>@doc.Name</td>
        <td>
            <span class="badge content-type-badge px-2 py-1 rounded-pill small">
                @doc.ContentType
            </span>

        </td>

        <td>@doc.ChunkCount</td>
        <td>@doc.LocalCreationDateString</td>
    }
}

@code {
    private ConfirmDialog dialog = default!;

    private UploadDocument Model { get; set; } = new();
    private Button uploadButton = default!;
    private Button deleteButton = default!;

    private bool isLoading = true;
    [Inject]
    protected ToastService ToastService { get; set; } = default!;
    private IList<SelectableDocument> documents = [];
    #region Methods

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }
        await using var scope = ServiceProvider.CreateAsyncScope();
        await LoadDocumentsAsync(scope.ServiceProvider);
        StateHasChanged();
    }

    private async Task LoadDocumentsAsync(IServiceProvider serviceProvider)
    {
        isLoading = true;

        try
        {
            var documentService = serviceProvider.GetRequiredService<IDocumentService>();
            var dbDocuments = await documentService.GetAsync();

            documents.Clear();
            foreach(var dbDocument in dbDocuments)
            {
                documents.Add(new SelectableDocument(dbDocument.Id, dbDocument.Name, dbDocument.creationDate, dbDocument.ChunkCount)
                    {
                        LocalCreationDateString = await GetLocalDateTimeStringAsync(dbDocument.creationDate)
                    });
            }            
        }
        catch (Exception ex)
        {
            ToastService.Notify(await CreateToastMessage(ToastType.Danger, "Load Error", $"An error occurred while loading documents: {ex.Message}"));
        }
        finally
        {
            isLoading = false;
        
        }
    }


    private async Task UploadFile()
    {
        if(Model.File is null)
        {
            return;
        }

        var fileName = Model.File.Name;
        try
        {
            await using var inputStream = Model.File.OpenReadStream(20 * 1024 * 1024); // Limit to 20 MB
            await using var stream = await inputStream.GetMemoryStreamAsync();

            await using var scope = ServiceProvider.CreateAsyncScope();
            var vectorSearchService = scope.ServiceProvider.GetRequiredService<IVectorSearchService>();

            var documentId = string.IsNullOrWhiteSpace(Model.DocumentId) ? null : (Guid?)Guid.Parse(Model.DocumentId);
            await vectorSearchService.ImportAsync(stream, fileName, MimeUtility.GetMimeMapping(fileName), documentId);

            ToastService.Notify(await CreateToastMessage(ToastType.Success, "Upload document", $"The document {fileName} has been successfully uploaded and indexed."));

            Model = new UploadDocument();
            await JSRuntime.InvokeVoidAsync("resetFileInput", "fileInput");

            await LoadDocumentsAsync(scope.ServiceProvider);
        }
        catch (Exception ex)
        {
            ToastService.Notify(await CreateToastMessage(ToastType.Danger, "Upload Error", $"An error occurred while uploading the document {fileName}: {ex.Message}"));
        }
        finally
        {
            uploadButton.HideLoading();
        }

    }

    private async Task<ToastMessage> CreateToastMessage(ToastType toastType, string title, string message)
    {
        var toastMessage = new ToastMessage
        {
            Title = title,
            Message = message,
            Type = toastType,
            HelpText = await GetLocalDateTimeStringAsync(DateTimeOffset.UtcNow)
        };
        return toastMessage;
    }

    private async Task<string> GetLocalDateTimeStringAsync(DateTimeOffset dateTimeOffset)
    {
        var localDateTime = await JSRuntime.InvokeAsync<string>("getLocalTime", dateTimeOffset);
        return localDateTime;
    }
    #endregion


    #region Models
    public class UploadDocument
    {
        public IBrowserFile? File { get; set; }

        [RegularExpression(@"^(\{|\()?[0-9a-fA-F]{8}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{4}(-?)[0-9a-fA-F]{12}(\}|\))?$", ErrorMessage = "Invalid GUID format.")]
        public string? DocumentId { get; set; }
    }

    private record class SelectableDocument(Guid Id, string Name, DateTimeOffset CreationDate, int ChunkCount): Document(Id, Name, CreationDate, ChunkCount)
    {
        public bool IsSelected { get; set; }
        public string ContentType => MimeUtility.GetMimeMapping(Name);
        public string LocalCreationDateString { get; set; } = string.Empty;
    }
    #endregion
}