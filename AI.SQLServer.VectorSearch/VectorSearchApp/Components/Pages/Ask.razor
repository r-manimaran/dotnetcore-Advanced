@page "/ask"
@using System.Text.RegularExpressions
@inject IServiceProvider ServiceProvider
@inject IJSRuntime JSRuntime


<PageTitle>Chat with your data</PageTitle>
<div class="card mx-auto mt-2">
    <div class="card-body">
        @foreach(var message in messages)
        {
            <div class="d-flex align-items-baseline text-end justify-content-end">
                <div class="pe-2">
                    <div>
                        <div class="card card-text d-inline-block p-2 px-3 m-1">
                            <Markdown style="overflow-y:auto;">@message.Text</Markdown>
                        </div>
                    </div>
                </div>
                <div class="position-relative avatar">
                    <Image src="/images/user.png" class="img-fluid rounded-circle" alt=""/>
                </div>
            </div>
        }
        else if(message.Role =="assistant")
        {

        }
    </div>
</div>


@code {

    // private Button askButton = default!;
    // private Button resetButton = default!;
    private ElementReference askInput = default!;
    private ElementReference chat = default!;

    private IList<Message> messages = [];
    private string? question;
    private Guid conversationId = Guid.NewGuid();
    private bool isAsking = false;

    private void Reset()
    {
        question = null;
        conversationId = Guid.NewGuid();
        messages.Clear();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if(!firstRender)
        {
            return;
        }
        // await JSRuntime.InvokeVoidAsync("setFocus", askInput);
    }

    private async Task EnsureMessageIsVisibleAsync()
    {
        await JSRuntime.InvokeVoidAsync("scrollTo", chat);
    }
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if(isAsking){ return; }

        if(e.Type == "keydown" && e.Key == "Enter" && !string.IsNullOrWhiteSpace(question))
        {
            await AskQuestion();
        }
        else if( e.Key == "ArrowUp" && messages.Count >=2)
        {
            question = messages[^2].Text;
        }
    }

    private async Task AskQuestion()
    {
        isAsking = true;

        var userQuestion = new Question(conversationId, question!);
        var userMessage = new Message { Text = userQuestion.Text, Role = "user", Status = MessageStatus.Completed };
        messages.Add(userMessage);

        var assistantMessage = new Message { Role = "assistant", Status = MessageStatus.New };
        messages.Add(assistantMessage);

        question = null;
        await Task.Yield();

        await EnsureMessageIsVisibleAsync();
        try
        {
            await using var scope = ServiceProvider.CreateAsyncScope();
            var vectorSearchService = scope.ServiceProvider.GetRequiredService<IVectorSearchService>();

            var response = vectorSearchService.AskStreamingAsync(userQuestion);
            await foreach(var delta in response)
            {
                if(delta.streamState == StreamState.Start)
                {
                    userMessage.Text = delta.ReformuatedQuestion;
                    assistantMessage.TokenUsage = FormatTokenUsage(delta.TokenUsage);
                    assistantMessage.Status = MessageStatus.Streaming;
                }
                else if(delta.streamState == StreamState.Append)
                {
                    assistantMessage.Text += delta.Answer;
                }
                else if(delta.streamState ==  StreamState.End)
                {
                    // Get Citations from the answer
                    assistantMessage.Citations = delta.Citations?.Select(c=> new Citation
                    {
                        DocumentId = c.DocumentId,
                        ChunkId = c.ChunkId,
                        FileName = c.FileName,
                        Quote = c.Quote,
                        PageNumber = c.PageNumber,
                        IndexOnPage = c.IndexOnPage
                    });

                    assistantMessage.Status = MessageStatus.Completed;
                    assistantMessage.TokenUsage = FormatTokenUsage(delta.TokenUsage);
                }

                await Task.Yield();
                StateHasChanged();

                await EnsureMessageIsVisibleAsync();
            }


        }
        catch(Exception ex)
        {
            assistantMessage.Text = $"There was an error while processing the question: {ex.Message}";
            assistantMessage.Status = MessageStatus.Completed;
        }
        finally
        {
            await EnsureMessageIsVisibleAsync();

            isAsking = false;
        }
    }

    private static string FormatTokenUsage(TokenUsageResponse? tokenUsageResponse)
    {
        if (tokenUsageResponse is null)
        {
            return string.Empty;
        }
        var reformulation = tokenUsageResponse.Reformulation is not null
            ? $"<p><strong>Reformulation:</strong><br />{FormatTokenUsageDetails(tokenUsageResponse.Reformulation)}</p>"
            : string.Empty;

        var embeddingTokenCount = tokenUsageResponse.EmbeddingTokenCount.HasValue
            ? $"<p><strong>Embedding Token Count:</strong> {tokenUsageResponse.EmbeddingTokenCount}</p>"
            : string.Empty;

        var question = tokenUsageResponse.Question is not null
            ? $"<p><strong>Question:</strong><br />{FormatTokenUsageDetails(tokenUsageResponse.Question)}</p>"
            : string.Empty;

        return $"{reformulation}{embeddingTokenCount}{question}";

        static string FormatTokenUsageDetails(TokenUsage? tokenUsage)
        {
            if (tokenUsage is null)
            {
                return string.Empty;
            }

            return $"Prompt tokens: {tokenUsage.PromptTokens}<br />" +
                   $"Completion tokens: {tokenUsage.CompletionTokens}<br />" +
                   $"Total tokens: {tokenUsage.TokenTokens}";
        }
    }
    #region Models
    public enum MessageStatus
    {
        New,
        Streaming,
        Completed
    }

    public class Message
    {
        public string? Text { get; set; }
        
        public required string Role { get; set; }
        
        public MessageStatus Status { get; set; } = MessageStatus.New;
        
        public string? TokenUsage { get; set; }
        //List the citations extracted from the response
        
        public IEnumerable<Citation>? Citations { get; set; } 
    }

    public class Citation
    {
        public Guid DocumentId { get; set; }

        public Guid ChunkId { get; set; }

        public string FileName { get; set; } = null!;

        public string Quote { get; set; } = null!;
        
        public int? PageNumber { get; set; }
        
        public int IndexOnPage { get; set; }
    }
    #endregion
}